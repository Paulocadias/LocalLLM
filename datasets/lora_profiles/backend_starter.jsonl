{"instruction": "Create a REST API endpoint in Python Flask for getting user by ID", "response": "from flask import Flask, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\n\napp = Flask(__name__)\ndb = SQLAlchemy(app)\n\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    try:\n        user = User.query.get(user_id)\n        if not user:\n            return jsonify({'error': 'User not found'}), 404\n        \n        return jsonify({\n            'id': user.id,\n            'username': user.username,\n            'email': user.email,\n            'created_at': user.created_at.isoformat()\n        }), 200\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500"}
{"instruction": "Implement database connection pooling in Node.js with PostgreSQL", "response": "const { Pool } = require('pg');\n\n// Create connection pool\nconst pool = new Pool({\n    host: process.env.DB_HOST || 'localhost',\n    port: process.env.DB_PORT || 5432,\n    database: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    max: 20, // Maximum pool size\n    idleTimeoutMillis: 30000,\n    connectionTimeoutMillis: 2000,\n});\n\n// Error handling\npool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    process.exit(-1);\n});\n\n// Query function with automatic connection management\nasync function query(text, params) {\n    const start = Date.now();\n    const res = await pool.query(text, params);\n    const duration = Date.now() - start;\n    console.log('Executed query', { text, duration, rows: res.rowCount });\n    return res;\n}\n\nmodule.exports = { query, pool };"}
{"instruction": "Create a Redis caching middleware for Express.js", "response": "const redis = require('redis');\nconst client = redis.createClient({ url: process.env.REDIS_URL });\n\n// Connect to Redis\nclient.connect().catch(console.error);\n\n// Cache middleware\nfunction cacheMiddleware(duration = 300) {\n    return async (req, res, next) => {\n        if (req.method !== 'GET') {\n            return next();\n        }\n\n        const key = `cache:${req.originalUrl}`;\n\n        try {\n            // Check cache\n            const cachedResponse = await client.get(key);\n            \n            if (cachedResponse) {\n                console.log('Cache hit:', key);\n                return res.json(JSON.parse(cachedResponse));\n            }\n\n            // Cache miss - store response\n            const originalJson = res.json.bind(res);\n            res.json = async (data) => {\n                await client.setEx(key, duration, JSON.stringify(data));\n                console.log('Cached:', key);\n                return originalJson(data);\n            };\n\n            next();\n        } catch (error) {\n            console.error('Cache error:', error);\n            next();\n        }\n    };\n}\n\nmodule.exports = cacheMiddleware;"}
{"instruction": "Write a database migration script to add user roles table", "response": "-- Migration: Add user_roles table\n-- Version: 001\n-- Date: 2025-10-29\n\nBEGIN;\n\n-- Create roles table\nCREATE TABLE IF NOT EXISTS roles (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(50) UNIQUE NOT NULL,\n    description TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create user_roles junction table\nCREATE TABLE IF NOT EXISTS user_roles (\n    user_id INTEGER NOT NULL,\n    role_id INTEGER NOT NULL,\n    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (user_id, role_id),\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE\n);\n\n-- Create indexes\nCREATE INDEX idx_user_roles_user_id ON user_roles(user_id);\nCREATE INDEX idx_user_roles_role_id ON user_roles(role_id);\n\n-- Insert default roles\nINSERT INTO roles (name, description) VALUES\n    ('admin', 'System administrator with full access'),\n    ('user', 'Regular user with standard access'),\n    ('moderator', 'Content moderator');\n\nCOMMIT;"}
{"instruction": "Implement JWT authentication middleware in Python FastAPI", "response": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom jose import JWTError, jwt\nfrom datetime import datetime, timedelta\nimport os\n\nSECRET_KEY = os.getenv('JWT_SECRET_KEY')\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\nsecurity = HTTPBearer()\n\ndef create_access_token(data: dict, expires_delta: timedelta = None):\n    \"\"\"Generate JWT access token\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({'exp': expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Verify JWT token and extract user info\"\"\"\n    try:\n        token = credentials.credentials\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get('sub')\n        if user_id is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail='Invalid authentication credentials'\n            )\n        return payload\n    except JWTError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail='Invalid or expired token'\n        )}"}
