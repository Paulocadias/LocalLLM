{"instruction": "Create a simple RecyclerView adapter in Kotlin for displaying a list of strings", "response": "class SimpleStringAdapter(private val items: List<String>) : RecyclerView.Adapter<SimpleStringAdapter.ViewHolder>() {\n\n    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n        val textView: TextView = view.findViewById(R.id.textView)\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n        val view = LayoutInflater.from(parent.context)\n            .inflate(R.layout.item_simple_text, parent, false)\n        return ViewHolder(view)\n    }\n\n    override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n        holder.textView.text = items[position]\n    }\n\n    override fun getItemCount() = items.size\n}"}
{"instruction": "How do I observe LiveData in a ViewModel from an Android Activity?", "response": "To observe LiveData from a ViewModel in an Activity:\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: MyViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // Observe LiveData\n        viewModel.userData.observe(this) { user ->\n            // Update UI when data changes\n            textView.text = user.name\n        }\n    }\n}\n```\n\nKey points:\n1. Use `by viewModels()` delegate for ViewModel\n2. Call `observe()` with lifecycle owner (this)\n3. Lambda receives new value when data changes\n4. Observer is lifecycle-aware and auto-cleans up"}
{"instruction": "Write a Jetpack Compose function to display a user profile card with image and details", "response": "@Composable\nfun ProfileCard(\n    user: User,\n    modifier: Modifier = Modifier\n) {\n    Card(\n        modifier = modifier\n            .fillMaxWidth()\n            .padding(16.dp),\n        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n    ) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            // Profile Image\n            AsyncImage(\n                model = user.imageUrl,\n                contentDescription = \"Profile picture\",\n                modifier = Modifier\n                    .size(64.dp)\n                    .clip(CircleShape),\n                contentScale = ContentScale.Crop\n            )\n\n            Spacer(modifier = Modifier.width(16.dp))\n\n            // User Details\n            Column {\n                Text(\n                    text = user.name,\n                    style = MaterialTheme.typography.titleMedium,\n                    fontWeight = FontWeight.Bold\n                )\n                Text(\n                    text = user.email,\n                    style = MaterialTheme.typography.bodyMedium,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n                Text(\n                    text = user.bio,\n                    style = MaterialTheme.typography.bodySmall,\n                    maxLines = 2,\n                    overflow = TextOverflow.Ellipsis\n                )\n            }\n        }\n    }\n}"}
{"instruction": "Create a Kotlin coroutine function to fetch user data from an API with error handling", "response": "suspend fun fetchUserData(userId: String): Result<User> = withContext(Dispatchers.IO) {\n    try {\n        val response = apiService.getUser(userId)\n        if (response.isSuccessful) {\n            response.body()?.let { user ->\n                Result.success(user)\n            } ?: Result.failure(Exception(\"Empty response body\"))\n        } else {\n            Result.failure(Exception(\"HTTP ${response.code()}: ${response.message()}\"))\n        }\n    } catch (e: IOException) {\n        Result.failure(Exception(\"Network error: ${e.message}\", e))\n    } catch (e: Exception) {\n        Result.failure(Exception(\"Unexpected error: ${e.message}\", e))\n    }\n}\n\n// Usage in ViewModel:\nviewModelScope.launch {\n    fetchUserData(userId).fold(\n        onSuccess = { user ->\n            _userData.value = user\n        },\n        onFailure = { exception ->\n            _errorMessage.value = exception.message\n        }\n    )\n}"}
{"instruction": "How do I implement dependency injection with Hilt in an Android app?", "response": "Step-by-step Hilt implementation:\n\n1. **Add dependencies (build.gradle.kts):**\n```kotlin\nplugins {\n    id(\"com.google.dagger.hilt.android\")\n    id(\"kotlin-kapt\")\n}\n\ndependencies {\n    implementation(\"com.google.dagger:hilt-android:2.48\")\n    kapt(\"com.google.dagger:hilt-compiler:2.48\")\n}\n```\n\n2. **Application class:**\n```kotlin\n@HiltAndroidApp\nclass MyApplication : Application()\n```\n\n3. **Module for dependencies:**\n```kotlin\n@Module\n@InstallIn(SingletonComponent::class)\nobject AppModule {\n    @Provides\n    @Singleton\n    fun provideRetrofit(): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(\"https://api.example.com\")\n            .addConverterFactory(GsonConverterFactory.create())\n            .build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideApiService(retrofit: Retrofit): ApiService {\n        return retrofit.create(ApiService::class.java)\n    }\n}\n```\n\n4. **Inject into Activity:**\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    @Inject\n    lateinit var apiService: ApiService\n}\n```\n\n5. **Inject into ViewModel:**\n```kotlin\n@HiltViewModel\nclass MyViewModel @Inject constructor(\n    private val apiService: ApiService\n) : ViewModel() {\n    // ViewModel logic\n}\n```"}
